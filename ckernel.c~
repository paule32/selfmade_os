#define sgn(x) ((x<0)?-1:((x>0)?1:0)) /* macro to return the sign of a number */
                                         
typedef unsigned char  byte;
typedef unsigned short word;

byte *VGA = (byte *) 0xa0000;

extern plot_pixel(int,int,int);

void k_line_slow(int x1, int y1, int x2, int y2, byte color)
{
    int dx,dy,sdx,sdy,px,py,dxabs,dyabs,i;
    float slope;

    dx = x2 - x1;      /* the horizontal distance of the line */
    dy = y2 - y1;      /* the vertical distance of the line */
    dxabs = abs(dx);
    dyabs = abs(dy);
    sdx = sgn(dx);
    sdy = sgn(dy);
    if (dxabs >= dyabs) /* the line is more horizontal than vertical */
    {
        slope = (float)dy / (float)dx;
        for(i = 0;i != dx;i += sdx)
        {
            px = i+x1;
            py = slope*i+y1;
            plot_pixel(px,py,color);
        }
    }
    else /* the line is more vertical than horizontal */
    {
        slope = (float)dx / (float)dy;
        for(i = 0; i != dy; i +=sdy)
        {
            px = slope*i+x1;
            py = i + y1;
            plot_pixel(px,py,color);
        }
    }
}

void k_line_fast(int x1, int y1, int x2, int y2, byte color)
{
  int i,dx,dy,sdx,sdy,dxabs,dyabs,x,y,px,py;

  dx = x2-x1;      /* the horizontal distance of the line */
  dy = y2-y1;      /* the vertical distance of the line */
  dxabs = abs(dx);
  dyabs = abs(dy);
  sdx   = sgn(dx);
  sdy  = sgn(dy);
  x = dyabs >> 1;
  y = dxabs >> 1;
  px = x1;
  py = y1;

  VGA[(py<<8)+(py<<6)+px]=color;

  if (dxabs>=dyabs) /* the line is more horizontal than vertical */
  {
    for(i=0;i<dxabs;i++)
    {
      y+=dyabs;
      if (y>=dxabs)
      {
        y-=dxabs;
        py+=sdy;
      }
      px+=sdx;
      plot_pixel(px,py,color);
    }
  }
  else /* the line is more vertical than horizontal */
  {
    for(i=0;i<dyabs;i++)
    {
      x+=dxabs;
      if (x>=dyabs)
      {
        x-=dyabs;
        px+=sdx;
      }
      py+=sdy;
      plot_pixel(px,py,color);
    }
  }
}

void k_clear_screen()
{
    char* vidmem = (char*) 0xb8000;
    unsigned int i=0;
    while(i<(80*2*25))
    {
        vidmem[i] = ' ';
        ++i;
        vidmem[i] = 0x07;
        ++i;
    }
}

unsigned int k_printf(char* message, unsigned int line)
{
    char* vidmem = (char*) 0xb8000;
    unsigned int i = line*80*2;

    while(*message!=0)
    {
        if(*message==0x2F)
        {
            *message++;
            if(*message==0x6e)
            {
                line++;
                i=(line*80*2);
                *message++;
                if(*message==0){return(1);};
            }
        }
        vidmem[i]=*message;
        *message++;
        ++i;
        vidmem[i]=0x7;
        ++i;
    }
    return 1;
}

void outportb(unsigned int port,unsigned char value)
{
    asm volatile ("outb %%al,%%dx"::"d" (port), "a" (value));
}

void update_cursor(int row, int col)
{
    unsigned short    position=(row*80) + col;
    // cursor LOW port to vga INDEX register
    outportb(0x3D4, 0x0F);
    outportb(0x3D5, (unsigned char)(position&0xFF));
    // cursor HIGH port to vga INDEX register
    outportb(0x3D4, 0x0E);
    outportb(0x3D5, (unsigned char)((position>>8)&0xFF));
}

int RealEntry()
{
    k_clear_screen();
    k_printf("Welcome to MyOS.", 0);
    k_printf("The C kernel has been loaded.", 2);
    update_cursor(3, 0);
    return 0;
}
